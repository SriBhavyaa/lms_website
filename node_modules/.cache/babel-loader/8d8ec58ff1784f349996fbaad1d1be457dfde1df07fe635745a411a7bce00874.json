{"ast":null,"code":"(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? factory() : typeof define === 'function' && define.amd ? define('inert', factory) : factory();\n})(this, function () {\n  'use strict';\n\n  var _createClass = function () {\n    function defineProperties(target, props) {\n      for (var i = 0; i < props.length; i++) {\n        var descriptor = props[i];\n        descriptor.enumerable = descriptor.enumerable || false;\n        descriptor.configurable = true;\n        if (\"value\" in descriptor) descriptor.writable = true;\n        Object.defineProperty(target, descriptor.key, descriptor);\n      }\n    }\n    return function (Constructor, protoProps, staticProps) {\n      if (protoProps) defineProperties(Constructor.prototype, protoProps);\n      if (staticProps) defineProperties(Constructor, staticProps);\n      return Constructor;\n    };\n  }();\n  function _classCallCheck(instance, Constructor) {\n    if (!(instance instanceof Constructor)) {\n      throw new TypeError(\"Cannot call a class as a function\");\n    }\n  }\n\n  /**\n   * This work is licensed under the W3C Software and Document License\n   * (http://www.w3.org/Consortium/Legal/2015/copyright-software-and-document).\n   */\n\n  (function () {\n    // Return early if we're not running inside of the browser.\n    if (typeof window === 'undefined') {\n      return;\n    }\n\n    // Convenience function for converting NodeLists.\n    /** @type {typeof Array.prototype.slice} */\n    var slice = Array.prototype.slice;\n\n    /**\n     * IE has a non-standard name for \"matches\".\n     * @type {typeof Element.prototype.matches}\n     */\n    var matches = Element.prototype.matches || Element.prototype.msMatchesSelector;\n\n    /** @type {string} */\n    var _focusableElementsString = ['a[href]', 'area[href]', 'input:not([disabled])', 'select:not([disabled])', 'textarea:not([disabled])', 'button:not([disabled])', 'details', 'summary', 'iframe', 'object', 'embed', '[contenteditable]'].join(',');\n\n    /**\n     * `InertRoot` manages a single inert subtree, i.e. a DOM subtree whose root element has an `inert`\n     * attribute.\n     *\n     * Its main functions are:\n     *\n     * - to create and maintain a set of managed `InertNode`s, including when mutations occur in the\n     *   subtree. The `makeSubtreeUnfocusable()` method handles collecting `InertNode`s via registering\n     *   each focusable node in the subtree with the singleton `InertManager` which manages all known\n     *   focusable nodes within inert subtrees. `InertManager` ensures that a single `InertNode`\n     *   instance exists for each focusable node which has at least one inert root as an ancestor.\n     *\n     * - to notify all managed `InertNode`s when this subtree stops being inert (i.e. when the `inert`\n     *   attribute is removed from the root node). This is handled in the destructor, which calls the\n     *   `deregister` method on `InertManager` for each managed inert node.\n     */\n\n    var InertRoot = function () {\n      /**\n       * @param {!HTMLElement} rootElement The HTMLElement at the root of the inert subtree.\n       * @param {!InertManager} inertManager The global singleton InertManager object.\n       */\n      function InertRoot(rootElement, inertManager) {\n        _classCallCheck(this, InertRoot);\n\n        /** @type {!InertManager} */\n        this._inertManager = inertManager;\n\n        /** @type {!HTMLElement} */\n        this._rootElement = rootElement;\n\n        /**\n         * @type {!Set<!InertNode>}\n         * All managed focusable nodes in this InertRoot's subtree.\n         */\n        this._managedNodes = new Set();\n\n        // Make the subtree hidden from assistive technology\n        if (this._rootElement.hasAttribute('aria-hidden')) {\n          /** @type {?string} */\n          this._savedAriaHidden = this._rootElement.getAttribute('aria-hidden');\n        } else {\n          this._savedAriaHidden = null;\n        }\n        this._rootElement.setAttribute('aria-hidden', 'true');\n\n        // Make all focusable elements in the subtree unfocusable and add them to _managedNodes\n        this._makeSubtreeUnfocusable(this._rootElement);\n\n        // Watch for:\n        // - any additions in the subtree: make them unfocusable too\n        // - any removals from the subtree: remove them from this inert root's managed nodes\n        // - attribute changes: if `tabindex` is added, or removed from an intrinsically focusable\n        //   element, make that node a managed node.\n        this._observer = new MutationObserver(this._onMutation.bind(this));\n        this._observer.observe(this._rootElement, {\n          attributes: true,\n          childList: true,\n          subtree: true\n        });\n      }\n\n      /**\n       * Call this whenever this object is about to become obsolete.  This unwinds all of the state\n       * stored in this object and updates the state of all of the managed nodes.\n       */\n\n      _createClass(InertRoot, [{\n        key: 'destructor',\n        value: function destructor() {\n          this._observer.disconnect();\n          if (this._rootElement) {\n            if (this._savedAriaHidden !== null) {\n              this._rootElement.setAttribute('aria-hidden', this._savedAriaHidden);\n            } else {\n              this._rootElement.removeAttribute('aria-hidden');\n            }\n          }\n          this._managedNodes.forEach(function (inertNode) {\n            this._unmanageNode(inertNode.node);\n          }, this);\n\n          // Note we cast the nulls to the ANY type here because:\n          // 1) We want the class properties to be declared as non-null, or else we\n          //    need even more casts throughout this code. All bets are off if an\n          //    instance has been destroyed and a method is called.\n          // 2) We don't want to cast \"this\", because we want type-aware optimizations\n          //    to know which properties we're setting.\n          this._observer = /** @type {?} */null;\n          this._rootElement = /** @type {?} */null;\n          this._managedNodes = /** @type {?} */null;\n          this._inertManager = /** @type {?} */null;\n        }\n\n        /**\n         * @return {!Set<!InertNode>} A copy of this InertRoot's managed nodes set.\n         */\n      }, {\n        key: '_makeSubtreeUnfocusable',\n        /**\n         * @param {!Node} startNode\n         */\n        value: function _makeSubtreeUnfocusable(startNode) {\n          var _this2 = this;\n          composedTreeWalk(startNode, function (node) {\n            return _this2._visitNode(node);\n          });\n          var activeElement = document.activeElement;\n          if (!document.body.contains(startNode)) {\n            // startNode may be in shadow DOM, so find its nearest shadowRoot to get the activeElement.\n            var node = startNode;\n            /** @type {!ShadowRoot|undefined} */\n            var root = undefined;\n            while (node) {\n              if (node.nodeType === Node.DOCUMENT_FRAGMENT_NODE) {\n                root = /** @type {!ShadowRoot} */node;\n                break;\n              }\n              node = node.parentNode;\n            }\n            if (root) {\n              activeElement = root.activeElement;\n            }\n          }\n          if (startNode.contains(activeElement)) {\n            activeElement.blur();\n            // In IE11, if an element is already focused, and then set to tabindex=-1\n            // calling blur() will not actually move the focus.\n            // To work around this we call focus() on the body instead.\n            if (activeElement === document.activeElement) {\n              document.body.focus();\n            }\n          }\n        }\n\n        /**\n         * @param {!Node} node\n         */\n      }, {\n        key: '_visitNode',\n        value: function _visitNode(node) {\n          if (node.nodeType !== Node.ELEMENT_NODE) {\n            return;\n          }\n          var element = /** @type {!HTMLElement} */node;\n\n          // If a descendant inert root becomes un-inert, its descendants will still be inert because of\n          // this inert root, so all of its managed nodes need to be adopted by this InertRoot.\n          if (element !== this._rootElement && element.hasAttribute('inert')) {\n            this._adoptInertRoot(element);\n          }\n          if (matches.call(element, _focusableElementsString) || element.hasAttribute('tabindex')) {\n            this._manageNode(element);\n          }\n        }\n\n        /**\n         * Register the given node with this InertRoot and with InertManager.\n         * @param {!Node} node\n         */\n      }, {\n        key: '_manageNode',\n        value: function _manageNode(node) {\n          var inertNode = this._inertManager.register(node, this);\n          this._managedNodes.add(inertNode);\n        }\n\n        /**\n         * Unregister the given node with this InertRoot and with InertManager.\n         * @param {!Node} node\n         */\n      }, {\n        key: '_unmanageNode',\n        value: function _unmanageNode(node) {\n          var inertNode = this._inertManager.deregister(node, this);\n          if (inertNode) {\n            this._managedNodes['delete'](inertNode);\n          }\n        }\n\n        /**\n         * Unregister the entire subtree starting at `startNode`.\n         * @param {!Node} startNode\n         */\n      }, {\n        key: '_unmanageSubtree',\n        value: function _unmanageSubtree(startNode) {\n          var _this3 = this;\n          composedTreeWalk(startNode, function (node) {\n            return _this3._unmanageNode(node);\n          });\n        }\n\n        /**\n         * If a descendant node is found with an `inert` attribute, adopt its managed nodes.\n         * @param {!HTMLElement} node\n         */\n      }, {\n        key: '_adoptInertRoot',\n        value: function _adoptInertRoot(node) {\n          var inertSubroot = this._inertManager.getInertRoot(node);\n\n          // During initialisation this inert root may not have been registered yet,\n          // so register it now if need be.\n          if (!inertSubroot) {\n            this._inertManager.setInert(node, true);\n            inertSubroot = this._inertManager.getInertRoot(node);\n          }\n          inertSubroot.managedNodes.forEach(function (savedInertNode) {\n            this._manageNode(savedInertNode.node);\n          }, this);\n        }\n\n        /**\n         * Callback used when mutation observer detects subtree additions, removals, or attribute changes.\n         * @param {!Array<!MutationRecord>} records\n         * @param {!MutationObserver} self\n         */\n      }, {\n        key: '_onMutation',\n        value: function _onMutation(records, self) {\n          records.forEach(function (record) {\n            var target = /** @type {!HTMLElement} */record.target;\n            if (record.type === 'childList') {\n              // Manage added nodes\n              slice.call(record.addedNodes).forEach(function (node) {\n                this._makeSubtreeUnfocusable(node);\n              }, this);\n\n              // Un-manage removed nodes\n              slice.call(record.removedNodes).forEach(function (node) {\n                this._unmanageSubtree(node);\n              }, this);\n            } else if (record.type === 'attributes') {\n              if (record.attributeName === 'tabindex') {\n                // Re-initialise inert node if tabindex changes\n                this._manageNode(target);\n              } else if (target !== this._rootElement && record.attributeName === 'inert' && target.hasAttribute('inert')) {\n                // If a new inert root is added, adopt its managed nodes and make sure it knows about the\n                // already managed nodes from this inert subroot.\n                this._adoptInertRoot(target);\n                var inertSubroot = this._inertManager.getInertRoot(target);\n                this._managedNodes.forEach(function (managedNode) {\n                  if (target.contains(managedNode.node)) {\n                    inertSubroot._manageNode(managedNode.node);\n                  }\n                });\n              }\n            }\n          }, this);\n        }\n      }, {\n        key: 'managedNodes',\n        get: function get() {\n          return new Set(this._managedNodes);\n        }\n\n        /** @return {boolean} */\n      }, {\n        key: 'hasSavedAriaHidden',\n        get: function get() {\n          return this._savedAriaHidden !== null;\n        }\n\n        /** @param {?string} ariaHidden */\n      }, {\n        key: 'savedAriaHidden',\n        set: function set(ariaHidden) {\n          this._savedAriaHidden = ariaHidden;\n        }\n\n        /** @return {?string} */,\n\n        get: function get() {\n          return this._savedAriaHidden;\n        }\n      }]);\n      return InertRoot;\n    }();\n\n    /**\n     * `InertNode` initialises and manages a single inert node.\n     * A node is inert if it is a descendant of one or more inert root elements.\n     *\n     * On construction, `InertNode` saves the existing `tabindex` value for the node, if any, and\n     * either removes the `tabindex` attribute or sets it to `-1`, depending on whether the element\n     * is intrinsically focusable or not.\n     *\n     * `InertNode` maintains a set of `InertRoot`s which are descendants of this `InertNode`. When an\n     * `InertRoot` is destroyed, and calls `InertManager.deregister()`, the `InertManager` notifies the\n     * `InertNode` via `removeInertRoot()`, which in turn destroys the `InertNode` if no `InertRoot`s\n     * remain in the set. On destruction, `InertNode` reinstates the stored `tabindex` if one exists,\n     * or removes the `tabindex` attribute if the element is intrinsically focusable.\n     */\n\n    var InertNode = function () {\n      /**\n       * @param {!Node} node A focusable element to be made inert.\n       * @param {!InertRoot} inertRoot The inert root element associated with this inert node.\n       */\n      function InertNode(node, inertRoot) {\n        _classCallCheck(this, InertNode);\n\n        /** @type {!Node} */\n        this._node = node;\n\n        /** @type {boolean} */\n        this._overrodeFocusMethod = false;\n\n        /**\n         * @type {!Set<!InertRoot>} The set of descendant inert roots.\n         *    If and only if this set becomes empty, this node is no longer inert.\n         */\n        this._inertRoots = new Set([inertRoot]);\n\n        /** @type {?number} */\n        this._savedTabIndex = null;\n\n        /** @type {boolean} */\n        this._destroyed = false;\n\n        // Save any prior tabindex info and make this node untabbable\n        this.ensureUntabbable();\n      }\n\n      /**\n       * Call this whenever this object is about to become obsolete.\n       * This makes the managed node focusable again and deletes all of the previously stored state.\n       */\n\n      _createClass(InertNode, [{\n        key: 'destructor',\n        value: function destructor() {\n          this._throwIfDestroyed();\n          if (this._node && this._node.nodeType === Node.ELEMENT_NODE) {\n            var element = /** @type {!HTMLElement} */this._node;\n            if (this._savedTabIndex !== null) {\n              element.setAttribute('tabindex', this._savedTabIndex);\n            } else {\n              element.removeAttribute('tabindex');\n            }\n\n            // Use `delete` to restore native focus method.\n            if (this._overrodeFocusMethod) {\n              delete element.focus;\n            }\n          }\n\n          // See note in InertRoot.destructor for why we cast these nulls to ANY.\n          this._node = /** @type {?} */null;\n          this._inertRoots = /** @type {?} */null;\n          this._destroyed = true;\n        }\n\n        /**\n         * @type {boolean} Whether this object is obsolete because the managed node is no longer inert.\n         * If the object has been destroyed, any attempt to access it will cause an exception.\n         */\n      }, {\n        key: '_throwIfDestroyed',\n        /**\n         * Throw if user tries to access destroyed InertNode.\n         */\n        value: function _throwIfDestroyed() {\n          if (this.destroyed) {\n            throw new Error('Trying to access destroyed InertNode');\n          }\n        }\n\n        /** @return {boolean} */\n      }, {\n        key: 'ensureUntabbable',\n        /** Save the existing tabindex value and make the node untabbable and unfocusable */\n        value: function ensureUntabbable() {\n          if (this.node.nodeType !== Node.ELEMENT_NODE) {\n            return;\n          }\n          var element = /** @type {!HTMLElement} */this.node;\n          if (matches.call(element, _focusableElementsString)) {\n            if ( /** @type {!HTMLElement} */element.tabIndex === -1 && this.hasSavedTabIndex) {\n              return;\n            }\n            if (element.hasAttribute('tabindex')) {\n              this._savedTabIndex = /** @type {!HTMLElement} */element.tabIndex;\n            }\n            element.setAttribute('tabindex', '-1');\n            if (element.nodeType === Node.ELEMENT_NODE) {\n              element.focus = function () {};\n              this._overrodeFocusMethod = true;\n            }\n          } else if (element.hasAttribute('tabindex')) {\n            this._savedTabIndex = /** @type {!HTMLElement} */element.tabIndex;\n            element.removeAttribute('tabindex');\n          }\n        }\n\n        /**\n         * Add another inert root to this inert node's set of managing inert roots.\n         * @param {!InertRoot} inertRoot\n         */\n      }, {\n        key: 'addInertRoot',\n        value: function addInertRoot(inertRoot) {\n          this._throwIfDestroyed();\n          this._inertRoots.add(inertRoot);\n        }\n\n        /**\n         * Remove the given inert root from this inert node's set of managing inert roots.\n         * If the set of managing inert roots becomes empty, this node is no longer inert,\n         * so the object should be destroyed.\n         * @param {!InertRoot} inertRoot\n         */\n      }, {\n        key: 'removeInertRoot',\n        value: function removeInertRoot(inertRoot) {\n          this._throwIfDestroyed();\n          this._inertRoots['delete'](inertRoot);\n          if (this._inertRoots.size === 0) {\n            this.destructor();\n          }\n        }\n      }, {\n        key: 'destroyed',\n        get: function get() {\n          return (/** @type {!InertNode} */this._destroyed\n          );\n        }\n      }, {\n        key: 'hasSavedTabIndex',\n        get: function get() {\n          return this._savedTabIndex !== null;\n        }\n\n        /** @return {!Node} */\n      }, {\n        key: 'node',\n        get: function get() {\n          this._throwIfDestroyed();\n          return this._node;\n        }\n\n        /** @param {?number} tabIndex */\n      }, {\n        key: 'savedTabIndex',\n        set: function set(tabIndex) {\n          this._throwIfDestroyed();\n          this._savedTabIndex = tabIndex;\n        }\n\n        /** @return {?number} */,\n\n        get: function get() {\n          this._throwIfDestroyed();\n          return this._savedTabIndex;\n        }\n      }]);\n      return InertNode;\n    }();\n\n    /**\n     * InertManager is a per-document singleton object which manages all inert roots and nodes.\n     *\n     * When an element becomes an inert root by having an `inert` attribute set and/or its `inert`\n     * property set to `true`, the `setInert` method creates an `InertRoot` object for the element.\n     * The `InertRoot` in turn registers itself as managing all of the element's focusable descendant\n     * nodes via the `register()` method. The `InertManager` ensures that a single `InertNode` instance\n     * is created for each such node, via the `_managedNodes` map.\n     */\n\n    var InertManager = function () {\n      /**\n       * @param {!Document} document\n       */\n      function InertManager(document) {\n        _classCallCheck(this, InertManager);\n        if (!document) {\n          throw new Error('Missing required argument; InertManager needs to wrap a document.');\n        }\n\n        /** @type {!Document} */\n        this._document = document;\n\n        /**\n         * All managed nodes known to this InertManager. In a map to allow looking up by Node.\n         * @type {!Map<!Node, !InertNode>}\n         */\n        this._managedNodes = new Map();\n\n        /**\n         * All inert roots known to this InertManager. In a map to allow looking up by Node.\n         * @type {!Map<!Node, !InertRoot>}\n         */\n        this._inertRoots = new Map();\n\n        /**\n         * Observer for mutations on `document.body`.\n         * @type {!MutationObserver}\n         */\n        this._observer = new MutationObserver(this._watchForInert.bind(this));\n\n        // Add inert style.\n        addInertStyle(document.head || document.body || document.documentElement);\n\n        // Wait for document to be loaded.\n        if (document.readyState === 'loading') {\n          document.addEventListener('DOMContentLoaded', this._onDocumentLoaded.bind(this));\n        } else {\n          this._onDocumentLoaded();\n        }\n      }\n\n      /**\n       * Set whether the given element should be an inert root or not.\n       * @param {!HTMLElement} root\n       * @param {boolean} inert\n       */\n\n      _createClass(InertManager, [{\n        key: 'setInert',\n        value: function setInert(root, inert) {\n          if (inert) {\n            if (this._inertRoots.has(root)) {\n              // element is already inert\n              return;\n            }\n            var inertRoot = new InertRoot(root, this);\n            root.setAttribute('inert', '');\n            this._inertRoots.set(root, inertRoot);\n            // If not contained in the document, it must be in a shadowRoot.\n            // Ensure inert styles are added there.\n            if (!this._document.body.contains(root)) {\n              var parent = root.parentNode;\n              while (parent) {\n                if (parent.nodeType === 11) {\n                  addInertStyle(parent);\n                }\n                parent = parent.parentNode;\n              }\n            }\n          } else {\n            if (!this._inertRoots.has(root)) {\n              // element is already non-inert\n              return;\n            }\n            var _inertRoot = this._inertRoots.get(root);\n            _inertRoot.destructor();\n            this._inertRoots['delete'](root);\n            root.removeAttribute('inert');\n          }\n        }\n\n        /**\n         * Get the InertRoot object corresponding to the given inert root element, if any.\n         * @param {!Node} element\n         * @return {!InertRoot|undefined}\n         */\n      }, {\n        key: 'getInertRoot',\n        value: function getInertRoot(element) {\n          return this._inertRoots.get(element);\n        }\n\n        /**\n         * Register the given InertRoot as managing the given node.\n         * In the case where the node has a previously existing inert root, this inert root will\n         * be added to its set of inert roots.\n         * @param {!Node} node\n         * @param {!InertRoot} inertRoot\n         * @return {!InertNode} inertNode\n         */\n      }, {\n        key: 'register',\n        value: function register(node, inertRoot) {\n          var inertNode = this._managedNodes.get(node);\n          if (inertNode !== undefined) {\n            // node was already in an inert subtree\n            inertNode.addInertRoot(inertRoot);\n          } else {\n            inertNode = new InertNode(node, inertRoot);\n          }\n          this._managedNodes.set(node, inertNode);\n          return inertNode;\n        }\n\n        /**\n         * De-register the given InertRoot as managing the given inert node.\n         * Removes the inert root from the InertNode's set of managing inert roots, and remove the inert\n         * node from the InertManager's set of managed nodes if it is destroyed.\n         * If the node is not currently managed, this is essentially a no-op.\n         * @param {!Node} node\n         * @param {!InertRoot} inertRoot\n         * @return {?InertNode} The potentially destroyed InertNode associated with this node, if any.\n         */\n      }, {\n        key: 'deregister',\n        value: function deregister(node, inertRoot) {\n          var inertNode = this._managedNodes.get(node);\n          if (!inertNode) {\n            return null;\n          }\n          inertNode.removeInertRoot(inertRoot);\n          if (inertNode.destroyed) {\n            this._managedNodes['delete'](node);\n          }\n          return inertNode;\n        }\n\n        /**\n         * Callback used when document has finished loading.\n         */\n      }, {\n        key: '_onDocumentLoaded',\n        value: function _onDocumentLoaded() {\n          // Find all inert roots in document and make them actually inert.\n          var inertElements = slice.call(this._document.querySelectorAll('[inert]'));\n          inertElements.forEach(function (inertElement) {\n            this.setInert(inertElement, true);\n          }, this);\n\n          // Comment this out to use programmatic API only.\n          this._observer.observe(this._document.body || this._document.documentElement, {\n            attributes: true,\n            subtree: true,\n            childList: true\n          });\n        }\n\n        /**\n         * Callback used when mutation observer detects attribute changes.\n         * @param {!Array<!MutationRecord>} records\n         * @param {!MutationObserver} self\n         */\n      }, {\n        key: '_watchForInert',\n        value: function _watchForInert(records, self) {\n          var _this = this;\n          records.forEach(function (record) {\n            switch (record.type) {\n              case 'childList':\n                slice.call(record.addedNodes).forEach(function (node) {\n                  if (node.nodeType !== Node.ELEMENT_NODE) {\n                    return;\n                  }\n                  var inertElements = slice.call(node.querySelectorAll('[inert]'));\n                  if (matches.call(node, '[inert]')) {\n                    inertElements.unshift(node);\n                  }\n                  inertElements.forEach(function (inertElement) {\n                    this.setInert(inertElement, true);\n                  }, _this);\n                }, _this);\n                break;\n              case 'attributes':\n                if (record.attributeName !== 'inert') {\n                  return;\n                }\n                var target = /** @type {!HTMLElement} */record.target;\n                var inert = target.hasAttribute('inert');\n                _this.setInert(target, inert);\n                break;\n            }\n          }, this);\n        }\n      }]);\n      return InertManager;\n    }();\n\n    /**\n     * Recursively walk the composed tree from |node|.\n     * @param {!Node} node\n     * @param {(function (!HTMLElement))=} callback Callback to be called for each element traversed,\n     *     before descending into child nodes.\n     * @param {?ShadowRoot=} shadowRootAncestor The nearest ShadowRoot ancestor, if any.\n     */\n\n    function composedTreeWalk(node, callback, shadowRootAncestor) {\n      if (node.nodeType == Node.ELEMENT_NODE) {\n        var element = /** @type {!HTMLElement} */node;\n        if (callback) {\n          callback(element);\n        }\n\n        // Descend into node:\n        // If it has a ShadowRoot, ignore all child elements - these will be picked\n        // up by the <content> or <shadow> elements. Descend straight into the\n        // ShadowRoot.\n        var shadowRoot = /** @type {!HTMLElement} */element.shadowRoot;\n        if (shadowRoot) {\n          composedTreeWalk(shadowRoot, callback, shadowRoot);\n          return;\n        }\n\n        // If it is a <content> element, descend into distributed elements - these\n        // are elements from outside the shadow root which are rendered inside the\n        // shadow DOM.\n        if (element.localName == 'content') {\n          var content = /** @type {!HTMLContentElement} */element;\n          // Verifies if ShadowDom v0 is supported.\n          var distributedNodes = content.getDistributedNodes ? content.getDistributedNodes() : [];\n          for (var i = 0; i < distributedNodes.length; i++) {\n            composedTreeWalk(distributedNodes[i], callback, shadowRootAncestor);\n          }\n          return;\n        }\n\n        // If it is a <slot> element, descend into assigned nodes - these\n        // are elements from outside the shadow root which are rendered inside the\n        // shadow DOM.\n        if (element.localName == 'slot') {\n          var slot = /** @type {!HTMLSlotElement} */element;\n          // Verify if ShadowDom v1 is supported.\n          var _distributedNodes = slot.assignedNodes ? slot.assignedNodes({\n            flatten: true\n          }) : [];\n          for (var _i = 0; _i < _distributedNodes.length; _i++) {\n            composedTreeWalk(_distributedNodes[_i], callback, shadowRootAncestor);\n          }\n          return;\n        }\n      }\n\n      // If it is neither the parent of a ShadowRoot, a <content> element, a <slot>\n      // element, nor a <shadow> element recurse normally.\n      var child = node.firstChild;\n      while (child != null) {\n        composedTreeWalk(child, callback, shadowRootAncestor);\n        child = child.nextSibling;\n      }\n    }\n\n    /**\n     * Adds a style element to the node containing the inert specific styles\n     * @param {!Node} node\n     */\n    function addInertStyle(node) {\n      if (node.querySelector('style#inert-style, link#inert-style')) {\n        return;\n      }\n      var style = document.createElement('style');\n      style.setAttribute('id', 'inert-style');\n      style.textContent = '\\n' + '[inert] {\\n' + '  pointer-events: none;\\n' + '  cursor: default;\\n' + '}\\n' + '\\n' + '[inert], [inert] * {\\n' + '  -webkit-user-select: none;\\n' + '  -moz-user-select: none;\\n' + '  -ms-user-select: none;\\n' + '  user-select: none;\\n' + '}\\n';\n      node.appendChild(style);\n    }\n    if (!HTMLElement.prototype.hasOwnProperty('inert')) {\n      /** @type {!InertManager} */\n      var inertManager = new InertManager(document);\n      Object.defineProperty(HTMLElement.prototype, 'inert', {\n        enumerable: true,\n        /** @this {!HTMLElement} */\n        get: function get() {\n          return this.hasAttribute('inert');\n        },\n        /** @this {!HTMLElement} */\n        set: function set(inert) {\n          inertManager.setInert(this, inert);\n        }\n      });\n    }\n  })();\n});","map":{"version":3,"names":["global","factory","exports","module","define","amd","_createClass","defineProperties","target","props","i","length","descriptor","enumerable","configurable","writable","Object","defineProperty","key","Constructor","protoProps","staticProps","prototype","_classCallCheck","instance","TypeError","window","slice","Array","matches","Element","msMatchesSelector","_focusableElementsString","join","InertRoot","rootElement","inertManager","_inertManager","_rootElement","_managedNodes","Set","hasAttribute","_savedAriaHidden","getAttribute","setAttribute","_makeSubtreeUnfocusable","_observer","MutationObserver","_onMutation","bind","observe","attributes","childList","subtree","value","destructor","disconnect","removeAttribute","forEach","inertNode","_unmanageNode","node","startNode","_this2","composedTreeWalk","_visitNode","activeElement","document","body","contains","root","undefined","nodeType","Node","DOCUMENT_FRAGMENT_NODE","parentNode","blur","focus","ELEMENT_NODE","element","_adoptInertRoot","call","_manageNode","register","add","deregister","_unmanageSubtree","_this3","inertSubroot","getInertRoot","setInert","managedNodes","savedInertNode","records","self","record","type","addedNodes","removedNodes","attributeName","managedNode","get","set","ariaHidden","InertNode","inertRoot","_node","_overrodeFocusMethod","_inertRoots","_savedTabIndex","_destroyed","ensureUntabbable","_throwIfDestroyed","destroyed","Error","tabIndex","hasSavedTabIndex","addInertRoot","removeInertRoot","size","InertManager","_document","Map","_watchForInert","addInertStyle","head","documentElement","readyState","addEventListener","_onDocumentLoaded","inert","has","parent","_inertRoot","inertElements","querySelectorAll","inertElement","_this","unshift","callback","shadowRootAncestor","shadowRoot","localName","content","distributedNodes","getDistributedNodes","slot","_distributedNodes","assignedNodes","flatten","_i","child","firstChild","nextSibling","querySelector","style","createElement","textContent","appendChild","HTMLElement","hasOwnProperty"],"sources":["C:/Users/PS106257/Documents/journeyapp/node_modules/wicg-inert/dist/inert.js"],"sourcesContent":["(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? factory() :\n  typeof define === 'function' && define.amd ? define('inert', factory) :\n  (factory());\n}(this, (function () { 'use strict';\n\n  var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\n  function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n  /**\n   * This work is licensed under the W3C Software and Document License\n   * (http://www.w3.org/Consortium/Legal/2015/copyright-software-and-document).\n   */\n\n  (function () {\n    // Return early if we're not running inside of the browser.\n    if (typeof window === 'undefined') {\n      return;\n    }\n\n    // Convenience function for converting NodeLists.\n    /** @type {typeof Array.prototype.slice} */\n    var slice = Array.prototype.slice;\n\n    /**\n     * IE has a non-standard name for \"matches\".\n     * @type {typeof Element.prototype.matches}\n     */\n    var matches = Element.prototype.matches || Element.prototype.msMatchesSelector;\n\n    /** @type {string} */\n    var _focusableElementsString = ['a[href]', 'area[href]', 'input:not([disabled])', 'select:not([disabled])', 'textarea:not([disabled])', 'button:not([disabled])', 'details', 'summary', 'iframe', 'object', 'embed', '[contenteditable]'].join(',');\n\n    /**\n     * `InertRoot` manages a single inert subtree, i.e. a DOM subtree whose root element has an `inert`\n     * attribute.\n     *\n     * Its main functions are:\n     *\n     * - to create and maintain a set of managed `InertNode`s, including when mutations occur in the\n     *   subtree. The `makeSubtreeUnfocusable()` method handles collecting `InertNode`s via registering\n     *   each focusable node in the subtree with the singleton `InertManager` which manages all known\n     *   focusable nodes within inert subtrees. `InertManager` ensures that a single `InertNode`\n     *   instance exists for each focusable node which has at least one inert root as an ancestor.\n     *\n     * - to notify all managed `InertNode`s when this subtree stops being inert (i.e. when the `inert`\n     *   attribute is removed from the root node). This is handled in the destructor, which calls the\n     *   `deregister` method on `InertManager` for each managed inert node.\n     */\n\n    var InertRoot = function () {\n      /**\n       * @param {!HTMLElement} rootElement The HTMLElement at the root of the inert subtree.\n       * @param {!InertManager} inertManager The global singleton InertManager object.\n       */\n      function InertRoot(rootElement, inertManager) {\n        _classCallCheck(this, InertRoot);\n\n        /** @type {!InertManager} */\n        this._inertManager = inertManager;\n\n        /** @type {!HTMLElement} */\n        this._rootElement = rootElement;\n\n        /**\n         * @type {!Set<!InertNode>}\n         * All managed focusable nodes in this InertRoot's subtree.\n         */\n        this._managedNodes = new Set();\n\n        // Make the subtree hidden from assistive technology\n        if (this._rootElement.hasAttribute('aria-hidden')) {\n          /** @type {?string} */\n          this._savedAriaHidden = this._rootElement.getAttribute('aria-hidden');\n        } else {\n          this._savedAriaHidden = null;\n        }\n        this._rootElement.setAttribute('aria-hidden', 'true');\n\n        // Make all focusable elements in the subtree unfocusable and add them to _managedNodes\n        this._makeSubtreeUnfocusable(this._rootElement);\n\n        // Watch for:\n        // - any additions in the subtree: make them unfocusable too\n        // - any removals from the subtree: remove them from this inert root's managed nodes\n        // - attribute changes: if `tabindex` is added, or removed from an intrinsically focusable\n        //   element, make that node a managed node.\n        this._observer = new MutationObserver(this._onMutation.bind(this));\n        this._observer.observe(this._rootElement, { attributes: true, childList: true, subtree: true });\n      }\n\n      /**\n       * Call this whenever this object is about to become obsolete.  This unwinds all of the state\n       * stored in this object and updates the state of all of the managed nodes.\n       */\n\n\n      _createClass(InertRoot, [{\n        key: 'destructor',\n        value: function destructor() {\n          this._observer.disconnect();\n\n          if (this._rootElement) {\n            if (this._savedAriaHidden !== null) {\n              this._rootElement.setAttribute('aria-hidden', this._savedAriaHidden);\n            } else {\n              this._rootElement.removeAttribute('aria-hidden');\n            }\n          }\n\n          this._managedNodes.forEach(function (inertNode) {\n            this._unmanageNode(inertNode.node);\n          }, this);\n\n          // Note we cast the nulls to the ANY type here because:\n          // 1) We want the class properties to be declared as non-null, or else we\n          //    need even more casts throughout this code. All bets are off if an\n          //    instance has been destroyed and a method is called.\n          // 2) We don't want to cast \"this\", because we want type-aware optimizations\n          //    to know which properties we're setting.\n          this._observer = /** @type {?} */null;\n          this._rootElement = /** @type {?} */null;\n          this._managedNodes = /** @type {?} */null;\n          this._inertManager = /** @type {?} */null;\n        }\n\n        /**\n         * @return {!Set<!InertNode>} A copy of this InertRoot's managed nodes set.\n         */\n\n      }, {\n        key: '_makeSubtreeUnfocusable',\n\n\n        /**\n         * @param {!Node} startNode\n         */\n        value: function _makeSubtreeUnfocusable(startNode) {\n          var _this2 = this;\n\n          composedTreeWalk(startNode, function (node) {\n            return _this2._visitNode(node);\n          });\n\n          var activeElement = document.activeElement;\n\n          if (!document.body.contains(startNode)) {\n            // startNode may be in shadow DOM, so find its nearest shadowRoot to get the activeElement.\n            var node = startNode;\n            /** @type {!ShadowRoot|undefined} */\n            var root = undefined;\n            while (node) {\n              if (node.nodeType === Node.DOCUMENT_FRAGMENT_NODE) {\n                root = /** @type {!ShadowRoot} */node;\n                break;\n              }\n              node = node.parentNode;\n            }\n            if (root) {\n              activeElement = root.activeElement;\n            }\n          }\n          if (startNode.contains(activeElement)) {\n            activeElement.blur();\n            // In IE11, if an element is already focused, and then set to tabindex=-1\n            // calling blur() will not actually move the focus.\n            // To work around this we call focus() on the body instead.\n            if (activeElement === document.activeElement) {\n              document.body.focus();\n            }\n          }\n        }\n\n        /**\n         * @param {!Node} node\n         */\n\n      }, {\n        key: '_visitNode',\n        value: function _visitNode(node) {\n          if (node.nodeType !== Node.ELEMENT_NODE) {\n            return;\n          }\n          var element = /** @type {!HTMLElement} */node;\n\n          // If a descendant inert root becomes un-inert, its descendants will still be inert because of\n          // this inert root, so all of its managed nodes need to be adopted by this InertRoot.\n          if (element !== this._rootElement && element.hasAttribute('inert')) {\n            this._adoptInertRoot(element);\n          }\n\n          if (matches.call(element, _focusableElementsString) || element.hasAttribute('tabindex')) {\n            this._manageNode(element);\n          }\n        }\n\n        /**\n         * Register the given node with this InertRoot and with InertManager.\n         * @param {!Node} node\n         */\n\n      }, {\n        key: '_manageNode',\n        value: function _manageNode(node) {\n          var inertNode = this._inertManager.register(node, this);\n          this._managedNodes.add(inertNode);\n        }\n\n        /**\n         * Unregister the given node with this InertRoot and with InertManager.\n         * @param {!Node} node\n         */\n\n      }, {\n        key: '_unmanageNode',\n        value: function _unmanageNode(node) {\n          var inertNode = this._inertManager.deregister(node, this);\n          if (inertNode) {\n            this._managedNodes['delete'](inertNode);\n          }\n        }\n\n        /**\n         * Unregister the entire subtree starting at `startNode`.\n         * @param {!Node} startNode\n         */\n\n      }, {\n        key: '_unmanageSubtree',\n        value: function _unmanageSubtree(startNode) {\n          var _this3 = this;\n\n          composedTreeWalk(startNode, function (node) {\n            return _this3._unmanageNode(node);\n          });\n        }\n\n        /**\n         * If a descendant node is found with an `inert` attribute, adopt its managed nodes.\n         * @param {!HTMLElement} node\n         */\n\n      }, {\n        key: '_adoptInertRoot',\n        value: function _adoptInertRoot(node) {\n          var inertSubroot = this._inertManager.getInertRoot(node);\n\n          // During initialisation this inert root may not have been registered yet,\n          // so register it now if need be.\n          if (!inertSubroot) {\n            this._inertManager.setInert(node, true);\n            inertSubroot = this._inertManager.getInertRoot(node);\n          }\n\n          inertSubroot.managedNodes.forEach(function (savedInertNode) {\n            this._manageNode(savedInertNode.node);\n          }, this);\n        }\n\n        /**\n         * Callback used when mutation observer detects subtree additions, removals, or attribute changes.\n         * @param {!Array<!MutationRecord>} records\n         * @param {!MutationObserver} self\n         */\n\n      }, {\n        key: '_onMutation',\n        value: function _onMutation(records, self) {\n          records.forEach(function (record) {\n            var target = /** @type {!HTMLElement} */record.target;\n            if (record.type === 'childList') {\n              // Manage added nodes\n              slice.call(record.addedNodes).forEach(function (node) {\n                this._makeSubtreeUnfocusable(node);\n              }, this);\n\n              // Un-manage removed nodes\n              slice.call(record.removedNodes).forEach(function (node) {\n                this._unmanageSubtree(node);\n              }, this);\n            } else if (record.type === 'attributes') {\n              if (record.attributeName === 'tabindex') {\n                // Re-initialise inert node if tabindex changes\n                this._manageNode(target);\n              } else if (target !== this._rootElement && record.attributeName === 'inert' && target.hasAttribute('inert')) {\n                // If a new inert root is added, adopt its managed nodes and make sure it knows about the\n                // already managed nodes from this inert subroot.\n                this._adoptInertRoot(target);\n                var inertSubroot = this._inertManager.getInertRoot(target);\n                this._managedNodes.forEach(function (managedNode) {\n                  if (target.contains(managedNode.node)) {\n                    inertSubroot._manageNode(managedNode.node);\n                  }\n                });\n              }\n            }\n          }, this);\n        }\n      }, {\n        key: 'managedNodes',\n        get: function get() {\n          return new Set(this._managedNodes);\n        }\n\n        /** @return {boolean} */\n\n      }, {\n        key: 'hasSavedAriaHidden',\n        get: function get() {\n          return this._savedAriaHidden !== null;\n        }\n\n        /** @param {?string} ariaHidden */\n\n      }, {\n        key: 'savedAriaHidden',\n        set: function set(ariaHidden) {\n          this._savedAriaHidden = ariaHidden;\n        }\n\n        /** @return {?string} */\n        ,\n        get: function get() {\n          return this._savedAriaHidden;\n        }\n      }]);\n\n      return InertRoot;\n    }();\n\n    /**\n     * `InertNode` initialises and manages a single inert node.\n     * A node is inert if it is a descendant of one or more inert root elements.\n     *\n     * On construction, `InertNode` saves the existing `tabindex` value for the node, if any, and\n     * either removes the `tabindex` attribute or sets it to `-1`, depending on whether the element\n     * is intrinsically focusable or not.\n     *\n     * `InertNode` maintains a set of `InertRoot`s which are descendants of this `InertNode`. When an\n     * `InertRoot` is destroyed, and calls `InertManager.deregister()`, the `InertManager` notifies the\n     * `InertNode` via `removeInertRoot()`, which in turn destroys the `InertNode` if no `InertRoot`s\n     * remain in the set. On destruction, `InertNode` reinstates the stored `tabindex` if one exists,\n     * or removes the `tabindex` attribute if the element is intrinsically focusable.\n     */\n\n\n    var InertNode = function () {\n      /**\n       * @param {!Node} node A focusable element to be made inert.\n       * @param {!InertRoot} inertRoot The inert root element associated with this inert node.\n       */\n      function InertNode(node, inertRoot) {\n        _classCallCheck(this, InertNode);\n\n        /** @type {!Node} */\n        this._node = node;\n\n        /** @type {boolean} */\n        this._overrodeFocusMethod = false;\n\n        /**\n         * @type {!Set<!InertRoot>} The set of descendant inert roots.\n         *    If and only if this set becomes empty, this node is no longer inert.\n         */\n        this._inertRoots = new Set([inertRoot]);\n\n        /** @type {?number} */\n        this._savedTabIndex = null;\n\n        /** @type {boolean} */\n        this._destroyed = false;\n\n        // Save any prior tabindex info and make this node untabbable\n        this.ensureUntabbable();\n      }\n\n      /**\n       * Call this whenever this object is about to become obsolete.\n       * This makes the managed node focusable again and deletes all of the previously stored state.\n       */\n\n\n      _createClass(InertNode, [{\n        key: 'destructor',\n        value: function destructor() {\n          this._throwIfDestroyed();\n\n          if (this._node && this._node.nodeType === Node.ELEMENT_NODE) {\n            var element = /** @type {!HTMLElement} */this._node;\n            if (this._savedTabIndex !== null) {\n              element.setAttribute('tabindex', this._savedTabIndex);\n            } else {\n              element.removeAttribute('tabindex');\n            }\n\n            // Use `delete` to restore native focus method.\n            if (this._overrodeFocusMethod) {\n              delete element.focus;\n            }\n          }\n\n          // See note in InertRoot.destructor for why we cast these nulls to ANY.\n          this._node = /** @type {?} */null;\n          this._inertRoots = /** @type {?} */null;\n          this._destroyed = true;\n        }\n\n        /**\n         * @type {boolean} Whether this object is obsolete because the managed node is no longer inert.\n         * If the object has been destroyed, any attempt to access it will cause an exception.\n         */\n\n      }, {\n        key: '_throwIfDestroyed',\n\n\n        /**\n         * Throw if user tries to access destroyed InertNode.\n         */\n        value: function _throwIfDestroyed() {\n          if (this.destroyed) {\n            throw new Error('Trying to access destroyed InertNode');\n          }\n        }\n\n        /** @return {boolean} */\n\n      }, {\n        key: 'ensureUntabbable',\n\n\n        /** Save the existing tabindex value and make the node untabbable and unfocusable */\n        value: function ensureUntabbable() {\n          if (this.node.nodeType !== Node.ELEMENT_NODE) {\n            return;\n          }\n          var element = /** @type {!HTMLElement} */this.node;\n          if (matches.call(element, _focusableElementsString)) {\n            if ( /** @type {!HTMLElement} */element.tabIndex === -1 && this.hasSavedTabIndex) {\n              return;\n            }\n\n            if (element.hasAttribute('tabindex')) {\n              this._savedTabIndex = /** @type {!HTMLElement} */element.tabIndex;\n            }\n            element.setAttribute('tabindex', '-1');\n            if (element.nodeType === Node.ELEMENT_NODE) {\n              element.focus = function () {};\n              this._overrodeFocusMethod = true;\n            }\n          } else if (element.hasAttribute('tabindex')) {\n            this._savedTabIndex = /** @type {!HTMLElement} */element.tabIndex;\n            element.removeAttribute('tabindex');\n          }\n        }\n\n        /**\n         * Add another inert root to this inert node's set of managing inert roots.\n         * @param {!InertRoot} inertRoot\n         */\n\n      }, {\n        key: 'addInertRoot',\n        value: function addInertRoot(inertRoot) {\n          this._throwIfDestroyed();\n          this._inertRoots.add(inertRoot);\n        }\n\n        /**\n         * Remove the given inert root from this inert node's set of managing inert roots.\n         * If the set of managing inert roots becomes empty, this node is no longer inert,\n         * so the object should be destroyed.\n         * @param {!InertRoot} inertRoot\n         */\n\n      }, {\n        key: 'removeInertRoot',\n        value: function removeInertRoot(inertRoot) {\n          this._throwIfDestroyed();\n          this._inertRoots['delete'](inertRoot);\n          if (this._inertRoots.size === 0) {\n            this.destructor();\n          }\n        }\n      }, {\n        key: 'destroyed',\n        get: function get() {\n          return (/** @type {!InertNode} */this._destroyed\n          );\n        }\n      }, {\n        key: 'hasSavedTabIndex',\n        get: function get() {\n          return this._savedTabIndex !== null;\n        }\n\n        /** @return {!Node} */\n\n      }, {\n        key: 'node',\n        get: function get() {\n          this._throwIfDestroyed();\n          return this._node;\n        }\n\n        /** @param {?number} tabIndex */\n\n      }, {\n        key: 'savedTabIndex',\n        set: function set(tabIndex) {\n          this._throwIfDestroyed();\n          this._savedTabIndex = tabIndex;\n        }\n\n        /** @return {?number} */\n        ,\n        get: function get() {\n          this._throwIfDestroyed();\n          return this._savedTabIndex;\n        }\n      }]);\n\n      return InertNode;\n    }();\n\n    /**\n     * InertManager is a per-document singleton object which manages all inert roots and nodes.\n     *\n     * When an element becomes an inert root by having an `inert` attribute set and/or its `inert`\n     * property set to `true`, the `setInert` method creates an `InertRoot` object for the element.\n     * The `InertRoot` in turn registers itself as managing all of the element's focusable descendant\n     * nodes via the `register()` method. The `InertManager` ensures that a single `InertNode` instance\n     * is created for each such node, via the `_managedNodes` map.\n     */\n\n\n    var InertManager = function () {\n      /**\n       * @param {!Document} document\n       */\n      function InertManager(document) {\n        _classCallCheck(this, InertManager);\n\n        if (!document) {\n          throw new Error('Missing required argument; InertManager needs to wrap a document.');\n        }\n\n        /** @type {!Document} */\n        this._document = document;\n\n        /**\n         * All managed nodes known to this InertManager. In a map to allow looking up by Node.\n         * @type {!Map<!Node, !InertNode>}\n         */\n        this._managedNodes = new Map();\n\n        /**\n         * All inert roots known to this InertManager. In a map to allow looking up by Node.\n         * @type {!Map<!Node, !InertRoot>}\n         */\n        this._inertRoots = new Map();\n\n        /**\n         * Observer for mutations on `document.body`.\n         * @type {!MutationObserver}\n         */\n        this._observer = new MutationObserver(this._watchForInert.bind(this));\n\n        // Add inert style.\n        addInertStyle(document.head || document.body || document.documentElement);\n\n        // Wait for document to be loaded.\n        if (document.readyState === 'loading') {\n          document.addEventListener('DOMContentLoaded', this._onDocumentLoaded.bind(this));\n        } else {\n          this._onDocumentLoaded();\n        }\n      }\n\n      /**\n       * Set whether the given element should be an inert root or not.\n       * @param {!HTMLElement} root\n       * @param {boolean} inert\n       */\n\n\n      _createClass(InertManager, [{\n        key: 'setInert',\n        value: function setInert(root, inert) {\n          if (inert) {\n            if (this._inertRoots.has(root)) {\n              // element is already inert\n              return;\n            }\n\n            var inertRoot = new InertRoot(root, this);\n            root.setAttribute('inert', '');\n            this._inertRoots.set(root, inertRoot);\n            // If not contained in the document, it must be in a shadowRoot.\n            // Ensure inert styles are added there.\n            if (!this._document.body.contains(root)) {\n              var parent = root.parentNode;\n              while (parent) {\n                if (parent.nodeType === 11) {\n                  addInertStyle(parent);\n                }\n                parent = parent.parentNode;\n              }\n            }\n          } else {\n            if (!this._inertRoots.has(root)) {\n              // element is already non-inert\n              return;\n            }\n\n            var _inertRoot = this._inertRoots.get(root);\n            _inertRoot.destructor();\n            this._inertRoots['delete'](root);\n            root.removeAttribute('inert');\n          }\n        }\n\n        /**\n         * Get the InertRoot object corresponding to the given inert root element, if any.\n         * @param {!Node} element\n         * @return {!InertRoot|undefined}\n         */\n\n      }, {\n        key: 'getInertRoot',\n        value: function getInertRoot(element) {\n          return this._inertRoots.get(element);\n        }\n\n        /**\n         * Register the given InertRoot as managing the given node.\n         * In the case where the node has a previously existing inert root, this inert root will\n         * be added to its set of inert roots.\n         * @param {!Node} node\n         * @param {!InertRoot} inertRoot\n         * @return {!InertNode} inertNode\n         */\n\n      }, {\n        key: 'register',\n        value: function register(node, inertRoot) {\n          var inertNode = this._managedNodes.get(node);\n          if (inertNode !== undefined) {\n            // node was already in an inert subtree\n            inertNode.addInertRoot(inertRoot);\n          } else {\n            inertNode = new InertNode(node, inertRoot);\n          }\n\n          this._managedNodes.set(node, inertNode);\n\n          return inertNode;\n        }\n\n        /**\n         * De-register the given InertRoot as managing the given inert node.\n         * Removes the inert root from the InertNode's set of managing inert roots, and remove the inert\n         * node from the InertManager's set of managed nodes if it is destroyed.\n         * If the node is not currently managed, this is essentially a no-op.\n         * @param {!Node} node\n         * @param {!InertRoot} inertRoot\n         * @return {?InertNode} The potentially destroyed InertNode associated with this node, if any.\n         */\n\n      }, {\n        key: 'deregister',\n        value: function deregister(node, inertRoot) {\n          var inertNode = this._managedNodes.get(node);\n          if (!inertNode) {\n            return null;\n          }\n\n          inertNode.removeInertRoot(inertRoot);\n          if (inertNode.destroyed) {\n            this._managedNodes['delete'](node);\n          }\n\n          return inertNode;\n        }\n\n        /**\n         * Callback used when document has finished loading.\n         */\n\n      }, {\n        key: '_onDocumentLoaded',\n        value: function _onDocumentLoaded() {\n          // Find all inert roots in document and make them actually inert.\n          var inertElements = slice.call(this._document.querySelectorAll('[inert]'));\n          inertElements.forEach(function (inertElement) {\n            this.setInert(inertElement, true);\n          }, this);\n\n          // Comment this out to use programmatic API only.\n          this._observer.observe(this._document.body || this._document.documentElement, { attributes: true, subtree: true, childList: true });\n        }\n\n        /**\n         * Callback used when mutation observer detects attribute changes.\n         * @param {!Array<!MutationRecord>} records\n         * @param {!MutationObserver} self\n         */\n\n      }, {\n        key: '_watchForInert',\n        value: function _watchForInert(records, self) {\n          var _this = this;\n          records.forEach(function (record) {\n            switch (record.type) {\n              case 'childList':\n                slice.call(record.addedNodes).forEach(function (node) {\n                  if (node.nodeType !== Node.ELEMENT_NODE) {\n                    return;\n                  }\n                  var inertElements = slice.call(node.querySelectorAll('[inert]'));\n                  if (matches.call(node, '[inert]')) {\n                    inertElements.unshift(node);\n                  }\n                  inertElements.forEach(function (inertElement) {\n                    this.setInert(inertElement, true);\n                  }, _this);\n                }, _this);\n                break;\n              case 'attributes':\n                if (record.attributeName !== 'inert') {\n                  return;\n                }\n                var target = /** @type {!HTMLElement} */record.target;\n                var inert = target.hasAttribute('inert');\n                _this.setInert(target, inert);\n                break;\n            }\n          }, this);\n        }\n      }]);\n\n      return InertManager;\n    }();\n\n    /**\n     * Recursively walk the composed tree from |node|.\n     * @param {!Node} node\n     * @param {(function (!HTMLElement))=} callback Callback to be called for each element traversed,\n     *     before descending into child nodes.\n     * @param {?ShadowRoot=} shadowRootAncestor The nearest ShadowRoot ancestor, if any.\n     */\n\n\n    function composedTreeWalk(node, callback, shadowRootAncestor) {\n      if (node.nodeType == Node.ELEMENT_NODE) {\n        var element = /** @type {!HTMLElement} */node;\n        if (callback) {\n          callback(element);\n        }\n\n        // Descend into node:\n        // If it has a ShadowRoot, ignore all child elements - these will be picked\n        // up by the <content> or <shadow> elements. Descend straight into the\n        // ShadowRoot.\n        var shadowRoot = /** @type {!HTMLElement} */element.shadowRoot;\n        if (shadowRoot) {\n          composedTreeWalk(shadowRoot, callback, shadowRoot);\n          return;\n        }\n\n        // If it is a <content> element, descend into distributed elements - these\n        // are elements from outside the shadow root which are rendered inside the\n        // shadow DOM.\n        if (element.localName == 'content') {\n          var content = /** @type {!HTMLContentElement} */element;\n          // Verifies if ShadowDom v0 is supported.\n          var distributedNodes = content.getDistributedNodes ? content.getDistributedNodes() : [];\n          for (var i = 0; i < distributedNodes.length; i++) {\n            composedTreeWalk(distributedNodes[i], callback, shadowRootAncestor);\n          }\n          return;\n        }\n\n        // If it is a <slot> element, descend into assigned nodes - these\n        // are elements from outside the shadow root which are rendered inside the\n        // shadow DOM.\n        if (element.localName == 'slot') {\n          var slot = /** @type {!HTMLSlotElement} */element;\n          // Verify if ShadowDom v1 is supported.\n          var _distributedNodes = slot.assignedNodes ? slot.assignedNodes({ flatten: true }) : [];\n          for (var _i = 0; _i < _distributedNodes.length; _i++) {\n            composedTreeWalk(_distributedNodes[_i], callback, shadowRootAncestor);\n          }\n          return;\n        }\n      }\n\n      // If it is neither the parent of a ShadowRoot, a <content> element, a <slot>\n      // element, nor a <shadow> element recurse normally.\n      var child = node.firstChild;\n      while (child != null) {\n        composedTreeWalk(child, callback, shadowRootAncestor);\n        child = child.nextSibling;\n      }\n    }\n\n    /**\n     * Adds a style element to the node containing the inert specific styles\n     * @param {!Node} node\n     */\n    function addInertStyle(node) {\n      if (node.querySelector('style#inert-style, link#inert-style')) {\n        return;\n      }\n      var style = document.createElement('style');\n      style.setAttribute('id', 'inert-style');\n      style.textContent = '\\n' + '[inert] {\\n' + '  pointer-events: none;\\n' + '  cursor: default;\\n' + '}\\n' + '\\n' + '[inert], [inert] * {\\n' + '  -webkit-user-select: none;\\n' + '  -moz-user-select: none;\\n' + '  -ms-user-select: none;\\n' + '  user-select: none;\\n' + '}\\n';\n      node.appendChild(style);\n    }\n\n    if (!HTMLElement.prototype.hasOwnProperty('inert')) {\n      /** @type {!InertManager} */\n      var inertManager = new InertManager(document);\n\n      Object.defineProperty(HTMLElement.prototype, 'inert', {\n        enumerable: true,\n        /** @this {!HTMLElement} */\n        get: function get() {\n          return this.hasAttribute('inert');\n        },\n        /** @this {!HTMLElement} */\n        set: function set(inert) {\n          inertManager.setInert(this, inert);\n        }\n      });\n    }\n  })();\n\n})));\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}